package flowerbed

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"testing"

	"github.com/green-ecolution/green-ecolution-backend/internal/entities"
	"github.com/green-ecolution/green-ecolution-backend/internal/storage"
	sqlc "github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/_sqlc"
	"github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/flowerbed/mapper"
	"github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/flowerbed/mapper/generated"
	imgMapper "github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/image/mapper"
	imgMapperImpl "github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/image/mapper/generated"
	sensorMapper "github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/sensor/mapper"
	sensorMapperImpl "github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/sensor/mapper/generated"
	"github.com/green-ecolution/green-ecolution-backend/internal/storage/postgres/test"
	"github.com/green-ecolution/green-ecolution-backend/internal/utils"
	"github.com/jackc/pgx/v5"
	"github.com/stretchr/testify/assert"
)

var (
	dbUrl        string
	seedPath     string
	querier      sqlc.Querier
	mapperRepo   FlowerbedMappers
	defaultField struct {
		querier          sqlc.Querier
		FlowerbedMappers FlowerbedMappers
	}
)

func TestMain(m *testing.M) {
	rootDir := utils.RootDir()
	seedPath = fmt.Sprintf("%s/internal/storage/postgres/test/seed/flowerbed", rootDir)
	close, url, err := test.SetupPostgresContainer(seedPath)
	if err != nil {
		slog.Error("Error setting up postgres container", "error", err)
		os.Exit(1)
	}
	defer close()

	dbUrl = *url
	db, err := pgx.Connect(context.Background(), dbUrl)
	if err != nil {
		os.Exit(1)
	}
	querier = sqlc.New(db)
	mapperRepo = FlowerbedMappers{
		mapper:       &generated.InternalFlowerbedRepoMapperImpl{},
		sensorMapper: &sensorMapperImpl.InternalSensorRepoMapperImpl{},
		imgMapper:    &imgMapperImpl.InternalImageRepoMapperImpl{},
	}
	defaultField = struct {
		querier          sqlc.Querier
		FlowerbedMappers FlowerbedMappers
	}{
		querier:          querier,
		FlowerbedMappers: mapperRepo,
	}
	os.Exit(m.Run())
}

func TestNewFlowerbedMappers(t *testing.T) {
	type args struct {
		fMapper mapper.InternalFlowerbedRepoMapper
		iMapper imgMapper.InternalImageRepoMapper
		sMapper sensorMapper.InternalSensorRepoMapper
	}
	tests := []struct {
		name string
		args args
		want FlowerbedMappers
	}{
		{
			name: "Test NewFlowerbedMappers",
			args: args{
				fMapper: &generated.InternalFlowerbedRepoMapperImpl{},
				iMapper: &imgMapperImpl.InternalImageRepoMapperImpl{},
				sMapper: &sensorMapperImpl.InternalSensorRepoMapperImpl{},
			},
			want: FlowerbedMappers{
				mapper:       &generated.InternalFlowerbedRepoMapperImpl{},
				imgMapper:    &imgMapperImpl.InternalImageRepoMapperImpl{},
				sensorMapper: &sensorMapperImpl.InternalSensorRepoMapperImpl{},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := NewFlowerbedMappers(tt.args.fMapper, tt.args.iMapper, tt.args.sMapper)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestNewFlowerbedRepository(t *testing.T) {
	type args struct {
		querier sqlc.Querier
		mappers FlowerbedMappers
	}
	tests := []struct {
		name string
		args args
		want storage.FlowerbedRepository
	}{
		{
			name: "Test NewFlowerbedRepository",
			args: args{
				querier: querier,
				mappers: mapperRepo,
			},
			want: &FlowerbedRepository{
				querier:          querier,
				FlowerbedMappers: mapperRepo,
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := NewFlowerbedRepository(tt.args.querier, tt.args.mappers)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestFlowerbedRepository_GetAll(t *testing.T) {
	t.Run("call get all should return all flowerbeds", func(t *testing.T) {
		test.ResetDatabase(dbUrl, seedPath)

		// given
		repo := NewFlowerbedRepository(defaultField.querier, defaultField.FlowerbedMappers)
		expectedFlowerbeds := []*entities.Flowerbed{
			{
				ID: 1,
				Sensor: &entities.Sensor{
					ID:     1,
					Status: entities.SensorStatusOnline,
				},
				Size:           10,
				Description:    "Blumenbeet am Strand",
				NumberOfPlants: 5,
				MoistureLevel:  0.75,
				Region:         "Mürwik",
				Address:        "Solitüde Strand",
				Archived:       false,
				Latitude:       54.820940,
				Longitude:      9.489022,
			},
			{
				ID: 2,
				Sensor: &entities.Sensor{
					ID:     2,
					Status: entities.SensorStatusOffline,
				},
				Size:           11,
				Description:    "Blumenbeet beim Sankt-Jürgen-Platz",
				NumberOfPlants: 5,
				MoistureLevel:  0.5,
				Region:         "Jürgensby",
				Address:        "Ulmenstraße",
				Archived:       false,
				Latitude:       54.78805731048199,
				Longitude:      9.44400186680097,
				Images: []*entities.Image{
					{
						ID:       1,
						URL:      "https://avatars.githubusercontent.com/u/165842746?s=96&v=4",
						Filename: nil,
						MimeType: nil,
					},
					{
						ID:       2,
						URL:      "https://app.dev.green-ecolution.de/api/v1/images/avatar.png",
						Filename: utils.P("avatar.png"),
						MimeType: utils.P("image/png"),
					},
				},
			},
		}

		// when
		flowerbeds, err := repo.GetAll(context.Background())

		// then
		assert.NoError(t, err)
		assert.Equal(t, 2, len(flowerbeds))
		for i := range flowerbeds {
			assertFlowerbed(t, flowerbeds[i], expectedFlowerbeds[i])
		}
	})
}

func assertFlowerbed(t *testing.T, got, want *entities.Flowerbed) {
	if got == nil {
		assert.Nil(t, got)
		return
	}

	if want == nil {
		assert.Nil(t, want)
		return
	}

	assert.NotZero(t, got.CreatedAt)
	assert.NotZero(t, got.UpdatedAt)

	assert.Equal(t, want.ID, got.ID)
	assert.Equal(t, want.Size, got.Size)
	assert.Equal(t, want.Description, got.Description)
	assert.Equal(t, want.NumberOfPlants, got.NumberOfPlants)
	assert.Equal(t, want.MoistureLevel, got.MoistureLevel)
	assert.Equal(t, want.Region, got.Region)
	assert.Equal(t, want.Address, got.Address)
	assert.Equal(t, want.Archived, got.Archived)
	assert.Equal(t, want.Latitude, got.Latitude)
	assert.Equal(t, want.Longitude, got.Longitude)

	assert.NotZero(t, got.Sensor.CreatedAt)
	assert.NotZero(t, got.Sensor.UpdatedAt)
	assert.Equal(t, got.Sensor.ID, want.Sensor.ID)
	assert.Equal(t, got.Sensor.Status, want.Sensor.Status)

	assert.Len(t, got.Images, len(want.Images))
	for i := range got.Images {
		assertImage(t, got.Images[i], want.Images[i])
	}

	assertSensor(t, got.Sensor, want.Sensor)
}

func assertSensor(t *testing.T, got, want *entities.Sensor) {
	if got == nil {
		assert.Nil(t, got)
		return
	}

	if want == nil {
		assert.Nil(t, want)
		return
	}

	assert.NotZero(t, got.CreatedAt)
	assert.NotZero(t, got.UpdatedAt)

	assert.Equal(t, want.ID, got.ID)
	assert.Equal(t, want.Status, got.Status)
}

func assertImage(t *testing.T, got, want *entities.Image) {
	if got == nil {
		assert.Nil(t, got)
		return
	}

	if want == nil {
		assert.Nil(t, want)
		return
	}

	assert.Equal(t, want.ID, got.ID)
	assert.Equal(t, want.URL, got.URL)
	assert.Equal(t, want.Filename, got.Filename)
	assert.Equal(t, want.MimeType, got.MimeType)
}
